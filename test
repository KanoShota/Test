# cf_cookie_min_hardcoded.py
# pip install botocore cryptography
import json, datetime as dt
from flask import Blueprint, make_response, request, abort, jsonify
from botocore.signers import CloudFrontSigner
from cryptography.hazmat.primitives import serialization

bp = Blueprint("cf_cookie_min", __name__)

# ==== ここだけ書き換えればOK ==========================================
CF_KEY_PAIR_ID = "KXXXXXXXXXXXXXXXXX"          # CloudFront Public key の Key ID
CF_DOMAIN      = "video.dev.example.com"       # CloudFront の配信ドメイン（CNAME 推奨）
COOKIE_DOMAIN  = ".dev.example.com"            # Cookie を送るドメイン（配信に届くように親ドメインを揃える）
TTL_SEC        = 600                           # 10分（最初はこれでOK）
RESOURCE_PATH  = "/protected/*"                # Cookie を有効にするパス

# Secureクッキー: ローカルの http でテストするだけなら False にするとCookieは入る（がCFには届かない）
SECURE_COOKIE  = True

# 秘密鍵（どちらか片方でOK）
CF_PRIVATE_KEY_PEM = b"""-----BEGIN PRIVATE KEY-----
...ここにあなたのPEM（秘密鍵）...
-----END PRIVATE KEY-----"""
# CF_PRIVATE_KEY_PATH = "cf_private_key.pem"
# =====================================================================

def _load_private_key_bytes() -> bytes:
    if CF_PRIVATE_KEY_PEM and b"BEGIN" in CF_PRIVATE_KEY_PEM:
        return CF_PRIVATE_KEY_PEM
    # ファイルで持つ場合は↑を空にしてこっちを使う
    # with open(CF_PRIVATE_KEY_PATH, "rb") as f:
    #     return f.read()
    raise RuntimeError("秘密鍵が未設定です。CF_PRIVATE_KEY_PEM または CF_PRIVATE_KEY_PATH を設定してください。")

def _rsa_signer(message: bytes) -> bytes:
    key = serialization.load_pem_private_key(_load_private_key_bytes(), password=None)
    return key.sign(message)

def _require_authenticated_user():
    # 既存の認証判定に置き換えてください（下行はダミー）
    if not request.headers.get("X-Dummy-Auth"):
        abort(401)

@bp.post("/issue")   # ログイン直後に呼ぶ
def issue():
    _require_authenticated_user()

    expire = int((dt.datetime.utcnow() + dt.timedelta(seconds=TTL_SEC)).timestamp())
    policy = {
        "Statement": [{
            "Resource": f"https://{CF_DOMAIN}{RESOURCE_PATH}",
            "Condition": {"DateLessThan": {"AWS:EpochTime": expire}}
        }]
    }

    signer = CloudFrontSigner(CF_KEY_PAIR_ID, _rsa_signer)
    cookies = signer.generate_signed_cookie(url=None, policy=json.dumps(policy).encode("utf-8"))

    resp = make_response(jsonify({"ok": True, "ttlSec": TTL_SEC}))
    common = dict(
        max_age=TTL_SEC,
        secure=SECURE_COOKIE,
        httponly=True,
        samesite="Lax",
        domain=COOKIE_DOMAIN,
        path="/",
    )
    for k, v in cookies.items():
        resp.set_cookie(k, v, **common)
    return resp

@bp.post("/clear")   # ログアウト時など
def clear():
    resp = make_response(jsonify({"ok": True}))
    for k in ("CloudFront-Policy", "CloudFront-Signature", "CloudFront-Key-Pair-Id"):
        resp.set_cookie(k, "", max_age=0, secure=SECURE_COOKIE, httponly=True, samesite="Lax",
                        domain=COOKIE_DOMAIN, path="/")
    return resp
