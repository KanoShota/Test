from flask import Flask, request
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import scoped_session, sessionmaker, declarative_base, Session as SASession
import gc
import psutil

# DB & Session設定
Base = declarative_base()
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    name = Column(String)

engine = create_engine("sqlite:///test.db", echo=False)
Session = scoped_session(sessionmaker(bind=engine))
Base.metadata.create_all(engine)

# 初期データ
s = Session()
if s.query(User).count() == 0:
    s.add_all([User(name=f"user_{i}") for i in range(1000)])
    s.commit()
Session.remove()

# Flaskアプリ
app = Flask(__name__)
PROC = psutil.Process()

@app.before_request
def before_request():
    s = Session()
    rss_kb = PROC.memory_info().rss // 1024
    live_sessions = sum(isinstance(obj, SASession) for obj in gc.get_objects())
    print(f"[BEGIN] {request.path} session_id={id(s)} identity_map={len(s.identity_map)} live_sessions≈{live_sessions} rss_kb={rss_kb}")

@app.after_request
def after_request(response):
    s = Session()
    rss_kb = PROC.memory_info().rss // 1024
    live_sessions = sum(isinstance(obj, SASession) for obj in gc.get_objects())
    print(f"[AFTER] {request.path} session_id={id(s)} identity_map={len(s.identity_map)} live_sessions≈{live_sessions} rss_kb={rss_kb}")
    return response

@app.teardown_appcontext
def teardown(exception=None):
    # ★ remove にするとセッション再利用せず毎回新規
    Session.remove()
    rss_kb = PROC.memory_info().rss // 1024
    live_sessions = sum(isinstance(obj, SASession) for obj in gc.get_objects())
    print(f"[END] live_sessions≈{live_sessions} rss_kb={rss_kb}")

@app.get("/users")
def list_users():
    s = Session()
    rows = s.query(User).limit(200).all()  # Identity Mapに200件乗せる
    return {"rows": len(rows)}

if __name__ == "__main__":
    app.run(debug=True)