sudo apt update
sudo apt install -y libreoffice libreoffice-calc libreoffice-common \
                    python3-venv
# 日本語表示用フォント（推奨）
sudo apt install -y fonts-noto-cjk fonts-ipafont-gothic fonts-ipafont-mincho \
                    fonts-noto-color-emoji

# サンプル: uploads/売上.xlsx を用意してから
libreoffice --headless --convert-to pdf --outdir ./out ./uploads/売上.xlsx
# → ./out/売上.pdf ができればOK

---------------------------------------------------------------------------------------------------------

# 先頭の import 群に追加（未追加なら）
from flask import url_for

# --- PDF.js を使った最小UI（白ベース・ページ送り + ズーム + ページ番号） ---
PDFJS_PAGE = """
<!doctype html><html><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>{{ filename }} | PDFビュー</title>
<style>
  :root { --bg:#fff; --fg:#111; --muted:#666; --border:#e5e7eb; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
             font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Noto Sans JP',sans-serif}
  header{position:sticky;top:0;background:#fff;border-bottom:1px solid var(--border);
         padding:10px 12px;display:flex;gap:10px;align-items:center}
  .title{flex:1 1 auto;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
         font-size:14px;color:var(--muted)}
  .btn{appearance:none;border:1px solid var(--border);background:#fff;border-radius:8px;
       padding:8px 12px;cursor:pointer}
  .btn[disabled]{opacity:.4;cursor:not-allowed}
  .counter{font-size:13px;color:var(--muted);display:flex;align-items:center;gap:6px}
  .counter input{width:64px;padding:6px;border:1px solid var(--border);border-radius:8px}
  .zoom{display:flex;align-items:center;gap:8px}
  .zoom .level{min-width:48px;text-align:right;font-variant-numeric:tabular-nums;color:var(--muted)}
  main{display:flex;justify-content:center;align-items:flex-start;padding:16px}
  canvas{box-shadow:0 1px 6px rgba(0,0,0,.06);background:#fff;max-width:100%}
  .grow{flex:1}
  .open-tab{margin-left:4px;font-size:12px;color:#2563eb;text-decoration:none}
</style>
</head><body>

<header>
  <div class="title">{{ filename }}</div>

  <!-- ページ送り -->
  <button id="prev" class="btn" aria-label="前のページ">◀</button>
  <div class="counter">
    <input id="page_input" type="number" min="1" value="1" aria-label="ページ番号">
    <span>/ <span id="page_count">?</span></span>
  </div>
  <button id="next" class="btn" aria-label="次のページ">▶</button>

  <!-- ズーム -->
  <div class="zoom">
    <button id="zoom_out" class="btn" aria-label="ズームアウト">−</button>
    <div class="level" id="zoom_level">100%</div>
    <button id="zoom_in" class="btn" aria-label="ズームイン">＋</button>
  </div>

  <div class="grow"></div>
  <!-- 別タブで開く（同じPDF.jsビューを別タブで） -->
  <a class="open-tab" href="{{ url_for('pdfjs_view', filename=filename) }}" target="_blank" rel="noopener">別タブで開く↗</a>
</header>

<main><canvas id="the-canvas"></canvas></main>

<!-- PDF.js（CDN） -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"
        integrity="sha512-PY4cJ0oI5J4oBVBR3mwb4F+T9qT8t2gE0y3o9J5oXQq2eB2m9m6sD6V5t7kG0T3g0yJpXz0i1r3q6a4f8b0l6A=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
  // ワーカーの場所（CDN）
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

  const url = {{ pdf_url|tojson }};
  const canvas = document.getElementById('the-canvas');
  const ctx = canvas.getContext('2d');
  const pageInput = document.getElementById('page_input');
  const pageCountSpan = document.getElementById('page_count');
  const btnPrev = document.getElementById('prev');
  const btnNext = document.getElementById('next');
  const btnZoomIn = document.getElementById('zoom_in');
  const btnZoomOut = document.getElementById('zoom_out');
  const zoomLevel = document.getElementById('zoom_level');

  let pdfDoc = null;
  let pageNum = 1;

  // ズーム制御：画面サイズにフィットする基準倍率 × 追加倍率（ユーザー操作）
  let baseScale = 1;     // ウィンドウに応じて計算
  let userScale = 1;     // ユーザーが変更（0.5〜3.0）
  const USER_MIN = 0.5, USER_MAX = 3.0, USER_STEP = 0.1;

  function clamp(v, lo, hi) { return Math.min(Math.max(v, lo), hi); }

  function updateZoomLabel() {
    zoomLevel.textContent = Math.round(userScale * 100) + "%";
  }

  function computeBaseScale(page) {
    const viewport = page.getViewport({ scale: 1 });
    const maxWidth = Math.min(window.innerWidth - 32, 1400); // 上限幅
    let scale = maxWidth / viewport.width;
    // 高さが収まり切らない場合は少し縮小
    if (viewport.height * scale > window.innerHeight * 0.9) {
      scale = (window.innerHeight * 0.9) / viewport.height;
    }
    return scale;
  }

  let isRendering = false;
  let pendingPage = null;

  function renderPage(num) {
    isRendering = true;
    pdfDoc.getPage(num).then(function(page) {
      // リサイズで baseScale を再計算（ページごとにサイズ差があっても自然に合わせる）
      baseScale = computeBaseScale(page);
      const scale = baseScale * userScale;
      const viewport = page.getViewport({ scale });

      canvas.height = viewport.height;
      canvas.width = viewport.width;

      const renderTask = page.render({ canvasContext: ctx, viewport });
      renderTask.promise.then(function () {
        isRendering = false;
        pageInput.value = num;
        btnPrev.disabled = (num <= 1);
        btnNext.disabled = (num >= pdfDoc.numPages);
        if (pendingPage !== null) {
          const n = pendingPage; pendingPage = null;
          renderPage(n);
        }
      });
    });
  }

  function queueRenderPage(num) {
    if (isRendering) pendingPage = num;
    else renderPage(num);
  }

  function gotoPage(n) {
    n = clamp(n|0, 1, pdfDoc.numPages);
    if (n === pageNum) return;
    pageNum = n;
    queueRenderPage(pageNum);
  }

  // イベント
  btnPrev.addEventListener('click', () => gotoPage(pageNum - 1));
  btnNext.addEventListener('click', () => gotoPage(pageNum + 1));
  pageInput.addEventListener('change', () => gotoPage(parseInt(pageInput.value || "1", 10)));
  pageInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') gotoPage(parseInt(pageInput.value || "1", 10));
  });

  btnZoomIn.addEventListener('click', () => {
    userScale = clamp((userScale + USER_STEP), USER_MIN, USER_MAX);
    updateZoomLabel();
    queueRenderPage(pageNum);
  });
  btnZoomOut.addEventListener('click', () => {
    userScale = clamp((userScale - USER_STEP), USER_MIN, USER_MAX);
    updateZoomLabel();
    queueRenderPage(pageNum);
  });

  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') gotoPage(pageNum - 1);
    if (e.key === 'ArrowRight') gotoPage(pageNum + 1);
    if ((e.ctrlKey || e.metaKey) && (e.key === '=' || e.key === '+')) { // Ctrl/Cmd + +
      e.preventDefault(); userScale = clamp(userScale + USER_STEP, USER_MIN, USER_MAX);
      updateZoomLabel(); queueRenderPage(pageNum);
    }
    if ((e.ctrlKey || e.metaKey) && (e.key === '-')) { // Ctrl/Cmd + -
      e.preventDefault(); userScale = clamp(userScale - USER_STEP, USER_MIN, USER_MAX);
      updateZoomLabel(); queueRenderPage(pageNum);
    }
    if ((e.ctrlKey || e.metaKey) && (e.key === '0')) { // Ctrl/Cmd + 0 リセット
      e.preventDefault(); userScale = 1; updateZoomLabel(); queueRenderPage(pageNum);
    }
  });

  window.addEventListener('resize', () => queueRenderPage(pageNum));

  // 読み込み
  pdfjsLib.getDocument(url).promise.then(function(pdf) {
    pdfDoc = pdf;
    pageCountSpan.textContent = pdf.numPages;
    updateZoomLabel();
    // 初期表示
    pageNum = 1;
    renderPage(pageNum);
  }).catch(err => {
    alert("PDFの読み込みに失敗しました:\\n" + err.message);
  });
</script>
</body></html>
"""

@app.route("/pdfjs/<path:filename>")
def pdfjs_view(filename):
    # ここでは PDF データ自体は返さず、ビューだけ返す
    return render_template_string(
        PDFJS_PAGE,
        filename=filename,
        pdf_url=url_for('excel_pdf', filename=filename)  # 既存のPDF配信エンドポイント
    )


# app.py
from flask import Flask, render_template_string, send_file, abort, request, redirect, url_for
import subprocess, tempfile, shutil
from pathlib import Path
from werkzeug.exceptions import NotFound

app = Flask(__name__)

# ===== 設定 =====
UPLOAD_DIR = Path("uploads")      # Excel置き場
CACHE_DIR  = Path("out")          # 生成PDF置き場（サブフォルダも自動作成）
ALLOWED_EXTS = {".xlsx", ".xlsm", ".xls"}
app.config["MAX_CONTENT_LENGTH"] = 50 * 1024 * 1024  # 50MB

UPLOAD_DIR.mkdir(exist_ok=True, parents=True)
CACHE_DIR.mkdir(exist_ok=True, parents=True)

# ===== ユーティリティ =====
def _is_allowed(filename: str) -> bool:
    return Path(filename).suffix.lower() in ALLOWED_EXTS

def _safe_basename(filename: str) -> str:
    # パス区切り除去（Unicode保持）
    return Path(filename).name

def _unique_path(base_dir: Path, name: str) -> Path:
    """重複時は 'name (2).ext' 形式でユニーク化"""
    p = base_dir / name
    if not p.exists():
        return p
    stem, suf = Path(name).stem, Path(name).suffix
    i = 2
    while True:
        cand = base_dir / f"{stem} ({i}){suf}"
        if not cand.exists():
            return cand
        i += 1

def _resolve_under(root: Path, target: Path) -> Path:
    """root 配下かどうか検証しつつ絶対パス化"""
    root = root.resolve()
    abs_target = (root / target).resolve()
    if not str(abs_target).startswith(str(root)):
        raise NotFound()
    return abs_target

def _pdf_path_for(xls_abs: Path) -> Path:
    """UPLOAD_DIR配下の相対パス構造を保ったまま、out/ に .pdf を作る"""
    rel = xls_abs.relative_to(UPLOAD_DIR.resolve())
    pdf_abs = (CACHE_DIR / rel).with_suffix(".pdf")
    pdf_abs.parent.mkdir(parents=True, exist_ok=True)
    return pdf_abs

# ===== 変換 =====
def convert_xlsx_to_pdf(xls_abs: Path, pdf_abs: Path):
    if not xls_abs.exists():
        abort(404, "Excelが見つかりません")
    # 既にPDFがあり新しければ再変換しない
    if pdf_abs.exists() and pdf_abs.stat().st_mtime >= xls_abs.stat().st_mtime:
        return
    # 並列時のロック競合回避（ユーザープロファイルを一時領域に分離）
    tmp_profile = Path(tempfile.mkdtemp(prefix="lo-profile-"))
    try:
        cmd = [
            "libreoffice", "--headless",
            f"-env:UserInstallation=file://{tmp_profile.as_posix()}",
            "--convert-to", "pdf:calc_pdf_Export",
            "--outdir", str(pdf_abs.parent),
            str(xls_abs),
        ]
        subprocess.run(cmd, check=True, timeout=180)
        if not pdf_abs.exists():
            abort(500, "PDF生成に失敗しました")
    finally:
        shutil.rmtree(tmp_profile, ignore_errors=True)

# ===== 表示（PDF本体） =====
@app.route("/excel-pdf/<path:filename>")
def excel_pdf(filename):
    # uploads 配下に限定
    xls_abs = _resolve_under(UPLOAD_DIR, Path(filename))
    if not xls_abs.exists() or not _is_allowed(xls_abs.name):
        raise NotFound()

    pdf_abs = _pdf_path_for(xls_abs)
    convert_xlsx_to_pdf(xls_abs, pdf_abs)

    return send_file(
        pdf_abs,
        mimetype="application/pdf",
        as_attachment=False,
        download_name=pdf_abs.name,
        max_age=0,
        conditional=True,
        etag=True,
        last_modified=pdf_abs.stat().st_mtime
    )

# ===== ビューページ（iframeでPDFを表示） =====
PAGE = """
<!doctype html><meta charset="utf-8">
<title>{{ title }}</title>
<style>
  body{margin:0}
  .v{width:100vw;height:100vh;border:0}
</style>
<iframe class="v" src="{{ url_for('excel_pdf', filename=filename) }}" allowfullscreen></iframe>
"""

@app.route("/view/<path:filename>")
def view_excel(filename):
    return render_template_string(
        PAGE,
        title=f"{filename} の表示",
        filename=filename  # ← テンプレ側で url_for に渡す
    )

# ===== 一覧 + アップロード =====
INDEX_HTML = """
<!doctype html><meta charset="utf-8">
<title>Excel 一覧とアップロード</title>
<style>
  body{font-family:system-ui;margin:24px;line-height:1.6}
  h1{font-size:20px;margin:0 0 12px}
  form{margin:16px 0;padding:12px;border:1px solid #ddd;border-radius:8px;background:#fafafa}
  label{display:block;margin:8px 0 4px}
  input[type="text"]{width:420px;max-width:100%;padding:6px}
  input[type="file"]{padding:6px}
  button{padding:8px 14px;border:0;border-radius:8px;box-shadow:0 1px 0 rgba(0,0,0,.05);cursor:pointer}
  button.primary{background:#2f6fed;color:#fff}
  ul{padding-left:18px}
  li{margin:4px 0}
  .empty{color:#666}
  .msg{padding:8px 12px;background:#f0f7ff;border:1px solid #cfe3ff;border-radius:8px;margin:12px 0}
  code{background:#f5f5f5;padding:2px 6px;border-radius:4px}
  .small{color:#666;font-size:12px}
</style>

<h1>Excel 一覧（{{ files|length }} 件）</h1>

{% if msg %}<div class="msg">{{ msg|safe }}</div>{% endif %}

<form method="post" enctype="multipart/form-data">
  <h2 style="font-size:16px;margin:0 0 8px">アップロード</h2>
  <label>ファイル（.xlsx / .xlsm / .xls）</label>
  <input type="file" name="file" accept=".xlsx,.xlsm,.xls" required>

  <label>保存先サブフォルダ（任意）<span class="small">例: 部門A/2025</span></label>
  <input type="text" name="subdir" placeholder="サブフォルダ/さらに下層 など（未指定で直下）">

  <div style="margin-top:10px">
    <button class="primary" type="submit">アップロード</button>
  </div>
  <div class="small" style="margin-top:6px">最大 {{ max_mb }} MB。重複名は自動で (2), (3)… とリネーム。</div>
</form>

{% if files %}
  <ul>
  {% for f in files %}
    <li>
      <a href="{{ url_for('view_excel', filename=f) }}">{{ f }}</a>
      <small>（PDF表示）</small>
    </li>
  {% endfor %}
  </ul>
{% else %}
  <p class="empty">uploads/ に .xlsx / .xlsm / .xls を置くか、上のフォームからアップロードしてください。</p>
{% endif %}

<p>直接アクセス例：<code>/view/売上.xlsx</code> や <code>/excel-pdf/売上.xlsx</code></p>
"""

def _iter_excels():
    """uploads/ 配下の Excel を相対パス（POSIX）で列挙"""
    if not UPLOAD_DIR.exists():
        return []
    files = []
    for p in UPLOAD_DIR.rglob("*"):
        if p.is_file() and p.suffix.lower() in ALLOWED_EXTS:
            files.append(p.relative_to(UPLOAD_DIR).as_posix())
    return sorted(files)

@app.route("/", methods=["GET", "POST"])
def index():
    msg = ""
    if request.method == "POST":
        f = request.files.get("file")
        subdir = (request.form.get("subdir") or "").strip().strip("/")

        if not f or not f.filename:
            msg = "ファイルが指定されていません。"
        elif not _is_allowed(f.filename):
            msg = "対応していない拡張子です。(.xlsx / .xlsm / .xls のみ)"
        else:
            # 保存先ディレクトリ（サブフォルダは安全化＆作成）
            target_dir = UPLOAD_DIR
            if subdir:
                safe_subdir = Path(subdir).as_posix().lstrip("/")
                target_dir = _resolve_under(UPLOAD_DIR, Path(safe_subdir))
                target_dir.mkdir(parents=True, exist_ok=True)

            base = _safe_basename(f.filename)
            save_path = _unique_path(target_dir, base)
            f.save(save_path)

            rel = save_path.relative_to(UPLOAD_DIR).as_posix()
            view_link = url_for('view_excel', filename=rel)
            msg = f"アップロード完了：<a href='{view_link}'>{rel}</a> を表示"

        # PRGパターンでリロードの二重送信を防止
        return redirect(url_for("index", msg=msg))

    files = _iter_excels()
    return render_template_string(
        INDEX_HTML,
        files=files,
        msg=request.args.get("msg", ""),
        max_mb=int(app.config["MAX_CONTENT_LENGTH"] / (1024*1024))
    )

if __name__ == "__main__":
    app.run(debug=True)




