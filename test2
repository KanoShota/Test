# --------------------------------------------------------------------------------------------------
# excel_template_engine_anycol.py
# --------------------------------------------------------------------------------------------------
from openpyxl import load_workbook
from copy import copy

FOR_MARK = "{{ For TagBlock }}"
END_MARK = "{{ EndFor }}"
DATE_MARK = "{{ DATE_ROW }}"
STATS_MARK = "{{ STATS }}"

# コメント
def _find_cell(ws, token, start_row=1, start_col=1):
    """
    シート内で token を含むセルを上から検索して (row, col) を返す。
    見つからなければ (None, None) を返す（エラーにしない）。
    """
    for r in range(start_row, ws.max_row + 1):
        for c in range(start_col if r == start_row else 1, ws.max_column + 1):
            v = ws.cell(r, c).value
            if isinstance(v, str) and token in v:
                return r, c
    return None, None

# コメント
def _find_for_block(ws):
    """
    For/EndFor ブロックを検出して、((for_row, for_col), (end_row, end_col), template_row_list) を返す。
    見つからなければ ((None,None),(None,None),[]) を返す（エラーにしない）。
    """
    sr, sc = _find_cell(ws, FOR_MARK)
    if not sr:
        return (None, None), (None, None), []
    er, ec = _find_cell(ws, END_MARK, start_row=sr)
    if not er:
        return (sr, sc), (None, None), []
    template_rows = list(range(sr + 1, er))  # For〜EndFor の“間”
    return (sr, sc), (er, ec), template_rows

# コメント
def _clone_row(ws, src_row, dst_row):
    """
    src_row の見た目（値・書式）を保ったまま dst_row に行を挿入して複製する。
    """
    ws.insert_rows(dst_row)
    for c in range(1, ws.max_column + 1):
        s = ws.cell(src_row, c)
        d = ws.cell(dst_row, c)
        d.value = s.value
        d.number_format = s.number_format
        d.font = copy(s.font)
        d.border = copy(s.border)
        d.fill = copy(s.fill)
        d.alignment = copy(s.alignment)

# コメント
def _delete_rows(ws, start_row, end_row):
    """
    行範囲を削除する。start_row > end_row の場合は何もしない（エラーにしない）。
    """
    if not start_row or not end_row or start_row > end_row:
        return
    for _ in range(end_row - start_row + 1):
        ws.delete_rows(start_row)

# コメント
def _replace_all_in_row(ws, row, placeholder, replacement):
    """
    指定行の全セル文字列から placeholder を replacement に置換。
    文字列でないセルは無視。
    """
    if not row:
        return
    for c in range(1, ws.max_column + 1):
        v = ws.cell(row, c).value
        if isinstance(v, str) and placeholder in v:
            ws.cell(row, c, v.replace(placeholder, replacement))

# コメント
def _row_find_token_cols(ws, row, token):
    """
    指定行の中で token を含むセルの列番号リストを返す。
    見つからなければ空リスト。
    """
    cols = []
    if not row:
        return cols
    for c in range(1, ws.max_column + 1):
        v = ws.cell(row, c).value
        if isinstance(v, str) and token in v:
            cols.append(c)
    return cols

# コメント
def _fill_right(ws, row, col_start, values):
    """
    (row, col_start) から右方向に values を順に書き込む。row/col が無効なら何もしない。
    """
    if not row or not col_start:
        return
    for i, val in enumerate(values):
        ws.cell(row=row, column=col_start + i, value=val)

# コメント
def render_excel_with_dynamic_stats_anycol(
    template_path: str,
    out_path: str,
    calendar_days,     # List[date]
    blocks_data,       # List[{"LABEL":str,"STATS":[(key,disp)],"SERIES":{key:[...]}}]
):
    """
    任意列に置いたタグを検出し、For/EndFor ブロックを blocks_data で展開する。
    - タグ（For/EndFor/DATE_ROW/STATS）が無くてもエラーにせず可能な範囲で処理する。
    - DATE_ROW が無ければ日付行の横展開はスキップ。
    - STATS が無ければ統計行の展開はスキップ。
    - For/EndFor が無ければテンプレそのままを保存して終了。
    """
    wb = load_workbook(template_path)
    ws = wb.active

    # For ブロック検出（無ければそのまま保存して終了）
    (for_r, _), (end_r, _), tmpl_rows = _find_for_block(ws)
    if not tmpl_rows:
        wb.save(out_path)
        return

    # ひな形中の STATS 行（最初の1つ）と DATE 行（最初の1つ）を探す
    stats_row_rel = None
    date_row_rel = None
    for idx, r in enumerate(tmpl_rows):
        row_text = []
        for c in range(1, ws.max_column + 1):
            v = ws.cell(r, c).value
            if v is not None:
                row_text.append(str(v))
        row_text = "".join(row_text)
        if stats_row_rel is None and STATS_MARK in row_text:
            stats_row_rel = idx
        if date_row_rel is None and DATE_MARK in row_text:
            date_row_rel = idx
        if stats_row_rel is not None and date_row_rel is not None:
            break
    # なくても動作継続（後で分岐）

    insert_at = for_r
    for block in blocks_data or []:
        # 1) ひな形を1セット差し込み
        for r in tmpl_rows:
            _clone_row(ws, r, insert_at + 1)
            insert_at += 1
        new_rows = list(range(insert_at - len(tmpl_rows) + 1, insert_at + 1))

        # 2) LABEL 置換
        for r in new_rows:
            _replace_all_in_row(ws, r, "{{ LABEL }}", str(block.get("LABEL", "")))

        # 3) DATE_ROW：見つかっていれば、そのセルの右隣から横展開
        if date_row_rel is not None:
            date_row = new_rows[date_row_rel]
            date_cols = _row_find_token_cols(ws, date_row, DATE_MARK)
            if date_cols:
                dc = date_cols[0]
                v = ws.cell(date_row, dc).value or ""
                ws.cell(date_row, dc, (v.replace(DATE_MARK, "").strip() or "日付:"))
                _fill_right(ws, date_row, dc + 1, [d.isoformat() for d in (calendar_days or [])])

        # 4) STATS：見つかっていれば、トークンセル列を基準に行を増殖
        if stats_row_rel is not None:
            stats_row = new_rows[stats_row_rel]
            stats_cols = _row_find_token_cols(ws, stats_row, STATS_MARK)
            if stats_cols:
                sc = stats_cols[0]
                # 雛形 STATS 行のスタイルを保存
                style_cache = []
                for c in range(1, ws.max_column + 1):
                    s = ws.cell(stats_row, c)
                    style_cache.append((s.number_format, copy(s.font), copy(s.border), copy(s.fill), copy(s.alignment)))
                # 雛形 STATS 行を削除 → 選択統計ぶん挿入
                _delete_rows(ws, stats_row, stats_row)
                cur = stats_row
                for key, disp in (block.get("STATS") or []):
                    series = (block.get("SERIES") or {}).get(key, [])
                    ws.insert_rows(cur)
                    # スタイル適用
                    for c in range(1, ws.max_column + 1):
                        cell = ws.cell(cur, c)
                        nf, ft, bd, fl, al = style_cache[c-1]
                        cell.number_format = nf
                        cell.font = ft
                        cell.border = bd
                        cell.fill = fl
                        cell.alignment = al
                    # ラベル（トークンセル位置に出す）
                    ws.cell(cur, sc, f"{disp} :")
                    # 値を右へ
                    _fill_right(ws, cur, sc + 1, series)
                    cur += 1
                # STATS が空なら何もしない

    # 5) 元の For〜EndFor を削除（見つかれば削除。見つからなくてもエラーにしない）
    fr2, _ = _find_cell(ws, FOR_MARK)
    er2, _ = _find_cell(ws, END_MARK, start_row=fr2 or 1)
    if fr2 and er2 and fr2 <= er2:
        _delete_rows(ws, fr2, er2)

    wb.save(out_path)


# --------------------------------------------------------------------------------------------------
# example.py
# --------------------------------------------------------------------------------------------------


import argparse, json
from datetime import datetime, timedelta
from excel_template_engine_anycol import render_excel_with_dynamic_stats_anycol

# コメント
def build_calendar(from_date: str, to_date: str):
    """
    YYYY-MM-DD 形式の from/to（toは非含む）から日付配列を作る。
    不正な日付や未指定時は空配列を返す（エラーにしない）。
    """
    if not from_date or not to_date:
        return []
    try:
        f = datetime.fromisoformat(from_date).date()
        t = datetime.fromisoformat(to_date).date()
    except Exception:
        return []
    days = []
    cur = f
    while cur < t:
        days.append(cur)
        cur += timedelta(days=1)
    return days

# コメント
def load_blocks(json_path: str):
    """
    blocks.json を読み込み、必要なキーをゆるく整形して返す。
    形式:
      [
        {"LABEL":"TagA",
         "STATS":[["Sum","合計"],["Avg","平均"]],
         "SERIES":{"Sum":[...], "Avg":[...]}}
      ]
    足りないキーがあっても可能な範囲で解釈（エラーにしない）。
    """
    with open(json_path, "r", encoding="utf-8") as f:
        obj = json.load(f)

    blocks = []
    for b in (obj or []):
        label = b.get("LABEL", "")
        raw_stats = b.get("STATS") or []
        stats = []
        for s in raw_stats:
            try:
                key, disp = s[0], s[1]
            except Exception:
                continue
            stats.append((key, disp))
        blocks.append({
            "LABEL": label,
            "STATS": stats,
            "SERIES": b.get("SERIES", {}) or {}
        })
    return blocks

# コメント
def demo_blocks():
    """
    デモ用のダミーデータを返す。テンプレ動作確認用。
    """
    cal = build_calendar("2025-09-01", "2025-09-11")
    n = len(cal)
    return [
        {
            "LABEL": "TagA",
            "STATS": [("Sum","合計"), ("Avg","平均")],
            "SERIES": {
                "Sum": [100 + i*5 for i in range(n)],
                "Avg": [10 + i*0.5 for i in range(n)],
            }
        },
        {
            "LABEL": "TagB",
            "STATS": [("Max","最大")],
            "SERIES": {"Max": [20 + (i % 3) for i in range(n)]}
        }
    ], cal

# コメント
def main():
    """
    CLI 実行入口。テンプレとブロックデータを読み、Excel を生成する。
    例：
      python example.py --template template.xlsx --out report.xlsx
      python example.py --template template.xlsx --out report.xlsx \
        --from 2025-09-01 --to 2025-09-11 --blocks blocks.json
    """
    ap = argparse.ArgumentParser(description="Render Excel from template with dynamic stats (tolerant).")
    ap.add_argument("--template", "-t", default="template.xlsx", help="Path to template .xlsx")
    ap.add_argument("--out", "-o", default="report.xlsx", help="Path to output .xlsx")
    ap.add_argument("--from", dest="from_date", help="Start date YYYY-MM-DD (inclusive)")
    ap.add_argument("--to", dest="to_date", help="End date YYYY-MM-DD (exclusive)")
    ap.add_argument("--blocks", "-b", help="Path to blocks JSON file")
    args = ap.parse_args()

    if args.blocks:
        blocks = load_blocks(args.blocks)
        calendar_days = build_calendar(args.from_date, args.to_date)
    else:
        # デモデータ（--blocks未指定時）
        blocks, calendar_days = demo_blocks()

    render_excel_with_dynamic_stats_anycol(
        template_path=args.template,
        out_path=args.out,
        calendar_days=calendar_days,
        blocks_data=blocks
    )
    print(f"✅ Wrote: {args.out}")

# コメント
if __name__ == "__main__":
    main()


# --------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------

{{ For TagBlock }}
項目: {{ LABEL }}
日付: {{ DATE_ROW }}
{{ STATS }}
{{ EndFor }}


python example.py --template template.xlsx --out report.xlsx


# --------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------

blocks.json
[
  {
    "LABEL": "TagA",
    "STATS": [["Sum","合計"], ["Avg","平均"]],
    "SERIES": {
      "Sum": [100,120,110,130,140,160,150,170,165,180],
      "Avg": [10.0,12.0,11.0,13.0,14.0,16.0,15.0,17.0,16.5,18.0]
    }
  },
  {
    "LABEL": "TagB",
    "STATS": [["Max","最大"]],
    "SERIES": { "Max": [20,21,19,23,22,24,25,26,24,27] }
  }
]


ダミーを使って実行する例
python example.py \
  --template template.xlsx \
  --out report.xlsx \
  --from 2025-09-01 --to 2025-09-11 \
  --blocks blocks.json

