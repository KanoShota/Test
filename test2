# --------------------------------------------------------------------------------------------------
# excel_template_engine_anycol.py
# --------------------------------------------------------------------------------------------------
# excel_template_engine_anycol.py
import re
from openpyxl import load_workbook
from copy import copy

# ゆるいマッチ（空白の有無を許容）
FOR_PAT   = re.compile(r"\{\{\s*For\s+TagBlock\s*\}\}")
END_PAT   = re.compile(r"\{\{\s*EndFor\s*\}\}")
DATE_PAT  = re.compile(r"\{\{\s*DATE_ROW\s*\}\}")
STATS_PAT = re.compile(r"\{\{\s*STATS\s*\}\}")
LABEL_PAT = re.compile(r"\{\{\s*LABEL\s*\}\}")

# コメント
def _cell_has_token(value, pattern: re.Pattern) -> bool:
    """セル文字列 value が pattern にヒットするか（非文字列はFalse）。"""
    return isinstance(value, str) and bool(pattern.search(value))

# コメント
def _cell_replace_token(text: str, pattern: re.Pattern, replacement: str) -> str:
    """セル文字列内のトークン（pattern）を replacement に1回だけ置換。非文字列はそのまま。"""
    if not isinstance(text, str):
        return text
    return pattern.sub(replacement, text, count=1)

# コメント
def _find_cell(ws, pattern: re.Pattern, start_row=1, start_col=1):
    """シート内で最初に pattern にヒットするセル (row, col) を返す。無ければ (None, None)。"""
    for r in range(start_row, ws.max_row + 1):
        for c in range(start_col if r == start_row else 1, ws.max_column + 1):
            if _cell_has_token(ws.cell(r, c).value, pattern):
                return r, c
    return None, None

# コメント
def _find_for_block(ws):
    """
    For/EndFor ブロックの開始・終了セルと、間の行番号リストを返す。
    見つからなければ ((None,None),(None,None),[])。
    """
    sr, sc = _find_cell(ws, FOR_PAT)
    if not sr:
        return (None, None), (None, None), []
    er, ec = _find_cell(ws, END_PAT, start_row=sr)
    if not er:
        return (sr, sc), (None, None), []
    template_rows = list(range(sr + 1, er))
    return (sr, sc), (er, ec), template_rows

# コメント
def _clone_row(ws, src_row, dst_row):
    """src_row を丸ごと複製して dst_row に挿入（スタイルもコピー）。"""
    ws.insert_rows(dst_row)
    for c in range(1, ws.max_column + 1):
        s = ws.cell(src_row, c)
        d = ws.cell(dst_row, c)
        d.value = s.value
        d.number_format = s.number_format
        d.font = copy(s.font)
        d.border = copy(s.border)
        d.fill = copy(s.fill)
        d.alignment = copy(s.alignment)

# コメント
def _delete_rows(ws, start_row, end_row):
    """行範囲を削除。無効範囲は無視（エラーにしない）。"""
    if not start_row or not end_row or start_row > end_row:
        return
    for _ in range(end_row - start_row + 1):
        ws.delete_rows(start_row)

# コメント
def _replace_all_in_row(ws, row, pattern: re.Pattern, replacement: str):
    """指定行の全セルで pattern に一致する箇所を replacement に置換。"""
    if not row:
        return
    for c in range(1, ws.max_column + 1):
        v = ws.cell(row, c).value
        if isinstance(v, str) and pattern.search(v):
            ws.cell(row, c, pattern.sub(replacement, v))

# コメント
def _row_find_token_cells(ws, row, pattern: re.Pattern):
    """指定 row の中で pattern にマッチするセル列番号リスト。"""
    cols = []
    if not row:
        return cols
    for c in range(1, ws.max_column + 1):
        if _cell_has_token(ws.cell(row, c).value, pattern):
            cols.append(c)
    return cols

# コメント
def _fill_right(ws, row, col_start, values):
    """(row, col_start) から右方向へ values を順に書き込む。"""
    if not row or not col_start:
        return
    for i, val in enumerate(values):
        ws.cell(row=row, column=col_start + i, value=val)

# コメント
def render_excel_with_dynamic_stats_anycol(
    template_path: str,
    out_path: str,
    calendar_days,     # List[date]
    blocks_data,       # List[{"LABEL":str,"STATS":[(key,disp)],"SERIES":{key:[...]}}]
    remove_template_if_no_blocks: bool = False,  # 展開0件のとき For〜EndFor を残す（既定）
):
    """
    任意セルのタグを検出して For ブロックを展開する。
    - タグの空白ゆらぎを許容（{{For TagBlock}}, {{ For  TagBlock }} 等）
    - 1件以上の展開が成功したときだけ For〜EndFor を削除
    - 展開0件 or タグ欠落時はテンプレを維持（削除しない）
    """
    wb = load_workbook(template_path)
    ws = wb.active

    (for_r, _), (end_r, _), tmpl_rows = _find_for_block(ws)
    if not tmpl_rows:
        # ブロックが無いなら何もせず保存
        wb.save(out_path)
        return

    # ひな形内の STATS 行／DATE 行（最初に見つかったもの）
    stats_row_rel = None
    date_row_rel  = None
    for idx, r in enumerate(tmpl_rows):
        # 行文字列を生成（全セル連結）
        buf = []
        for c in range(1, ws.max_column + 1):
            v = ws.cell(r, c).value
            if v is not None:
                buf.append(str(v))
        row_text = "".join(buf)
        if stats_row_rel is None and STATS_PAT.search(row_text):
            stats_row_rel = idx
        if date_row_rel is None and DATE_PAT.search(row_text):
            date_row_rel = idx
        if stats_row_rel is not None and date_row_rel is not None:
            break

    insert_at = for_r
    expanded_blocks = 0

    for block in (blocks_data or []):
        # 1) ひな形を1セット複製挿入
        for r in tmpl_rows:
            _clone_row(ws, r, insert_at + 1)
            insert_at += 1
        new_rows = list(range(insert_at - len(tmpl_rows) + 1, insert_at + 1))

        # 2) LABEL 置換（行内の全セル）
        for r in new_rows:
            _replace_all_in_row(ws, r, LABEL_PAT, str(block.get("LABEL", "")))

        # 3) DATE_ROW：見つかっていれば、そのセルの右隣から横展開
        if date_row_rel is not None:
            date_row = new_rows[date_row_rel]
            date_cols = _row_find_token_cells(ws, date_row, DATE_PAT)
            if date_cols:
                dc = date_cols[0]
                val = ws.cell(date_row, dc).value or ""
                ws.cell(date_row, dc, _cell_replace_token(val, DATE_PAT, "").strip() or "日付:")
                _fill_right(ws, date_row, dc + 1, [d.isoformat() for d in (calendar_days or [])])

        # 4) STATS：見つかっていれば、テンプレ1行を選択統計の行数に展開
        did_stats = False
        if stats_row_rel is not None:
            stats_row = new_rows[stats_row_rel]
            stats_cols = _row_find_token_cells(ws, stats_row, STATS_PAT)
            if stats_cols:
                sc = stats_cols[0]
                # 雛形 STATS 行のスタイルを保持
                style_cache = []
                for c in range(1, ws.max_column + 1):
                    s = ws.cell(stats_row, c)
                    style_cache.append((s.number_format, copy(s.font), copy(s.border), copy(s.fill), copy(s.alignment)))
                # 雛形 STATS 行を消して、選択分だけ差し込む
                _delete_rows(ws, stats_row, stats_row)
                cur = stats_row
                for key, disp in (block.get("STATS") or []):
                    series = (block.get("SERIES") or {}).get(key, [])
                    ws.insert_rows(cur)
                    for c in range(1, ws.max_column + 1):
                        cell = ws.cell(cur, c)
                        nf, ft, bd, fl, al = style_cache[c-1]
                        cell.number_format = nf; cell.font = ft
                        cell.border = bd; cell.fill = fl; cell.alignment = al
                    ws.cell(cur, sc, f"{disp} :")
                    _fill_right(ws, cur, sc + 1, series)
                    cur += 1
                    did_stats = True

        if did_stats or date_row_rel is not None or LABEL_PAT:
            expanded_blocks += 1

    # 5) For〜EndFor を削除：展開が1件以上あった場合のみ
    if expanded_blocks > 0 or remove_template_if_no_blocks:
        fr2, _ = _find_cell(ws, FOR_PAT)
        er2, _ = _find_cell(ws, END_PAT, start_row=fr2 or 1)
        if fr2 and er2 and fr2 <= er2:
            _delete_rows(ws, fr2, er2)

    wb.save(out_path)



# --------------------------------------------------------------------------------------------------
# example.py
# --------------------------------------------------------------------------------------------------


import argparse, json
from datetime import datetime, timedelta
from excel_template_engine_anycol import render_excel_with_dynamic_stats_anycol

# コメント
def build_calendar(from_date: str, to_date: str):
    """
    YYYY-MM-DD 形式の from/to（toは非含む）から日付配列を作る。
    不正な日付や未指定時は空配列を返す（エラーにしない）。
    """
    if not from_date or not to_date:
        return []
    try:
        f = datetime.fromisoformat(from_date).date()
        t = datetime.fromisoformat(to_date).date()
    except Exception:
        return []
    days = []
    cur = f
    while cur < t:
        days.append(cur)
        cur += timedelta(days=1)
    return days

# コメント
def load_blocks(json_path: str):
    """
    blocks.json を読み込み、必要なキーをゆるく整形して返す。
    形式:
      [
        {"LABEL":"TagA",
         "STATS":[["Sum","合計"],["Avg","平均"]],
         "SERIES":{"Sum":[...], "Avg":[...]}}
      ]
    足りないキーがあっても可能な範囲で解釈（エラーにしない）。
    """
    with open(json_path, "r", encoding="utf-8") as f:
        obj = json.load(f)

    blocks = []
    for b in (obj or []):
        label = b.get("LABEL", "")
        raw_stats = b.get("STATS") or []
        stats = []
        for s in raw_stats:
            try:
                key, disp = s[0], s[1]
            except Exception:
                continue
            stats.append((key, disp))
        blocks.append({
            "LABEL": label,
            "STATS": stats,
            "SERIES": b.get("SERIES", {}) or {}
        })
    return blocks

# コメント
def demo_blocks():
    """
    デモ用のダミーデータを返す。テンプレ動作確認用。
    """
    cal = build_calendar("2025-09-01", "2025-09-11")
    n = len(cal)
    return [
        {
            "LABEL": "TagA",
            "STATS": [("Sum","合計"), ("Avg","平均")],
            "SERIES": {
                "Sum": [100 + i*5 for i in range(n)],
                "Avg": [10 + i*0.5 for i in range(n)],
            }
        },
        {
            "LABEL": "TagB",
            "STATS": [("Max","最大")],
            "SERIES": {"Max": [20 + (i % 3) for i in range(n)]}
        }
    ], cal

# コメント
def main():
    """
    CLI 実行入口。テンプレとブロックデータを読み、Excel を生成する。
    例：
      python example.py --template template.xlsx --out report.xlsx
      python example.py --template template.xlsx --out report.xlsx \
        --from 2025-09-01 --to 2025-09-11 --blocks blocks.json
    """
    ap = argparse.ArgumentParser(description="Render Excel from template with dynamic stats (tolerant).")
    ap.add_argument("--template", "-t", default="template.xlsx", help="Path to template .xlsx")
    ap.add_argument("--out", "-o", default="report.xlsx", help="Path to output .xlsx")
    ap.add_argument("--from", dest="from_date", help="Start date YYYY-MM-DD (inclusive)")
    ap.add_argument("--to", dest="to_date", help="End date YYYY-MM-DD (exclusive)")
    ap.add_argument("--blocks", "-b", help="Path to blocks JSON file")
    args = ap.parse_args()

    if args.blocks:
        blocks = load_blocks(args.blocks)
        calendar_days = build_calendar(args.from_date, args.to_date)
    else:
        # デモデータ（--blocks未指定時）
        blocks, calendar_days = demo_blocks()

    render_excel_with_dynamic_stats_anycol(
        template_path=args.template,
        out_path=args.out,
        calendar_days=calendar_days,
        blocks_data=blocks
    )
    print(f"✅ Wrote: {args.out}")

# コメント
if __name__ == "__main__":
    main()


# --------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------

{{ For TagBlock }}
項目: {{ LABEL }}
日付: {{ DATE_ROW }}
{{ STATS }}
{{ EndFor }}


python example.py --template template.xlsx --out report.xlsx


# --------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------

blocks.json
[
  {
    "LABEL": "TagA",
    "STATS": [["Sum","合計"], ["Avg","平均"]],
    "SERIES": {
      "Sum": [100,120,110,130,140,160,150,170,165,180],
      "Avg": [10.0,12.0,11.0,13.0,14.0,16.0,15.0,17.0,16.5,18.0]
    }
  },
  {
    "LABEL": "TagB",
    "STATS": [["Max","最大"]],
    "SERIES": { "Max": [20,21,19,23,22,24,25,26,24,27] }
  }
]


ダミーを使って実行する例
python example.py \
  --template template.xlsx \
  --out report.xlsx \
  --from 2025-09-01 --to 2025-09-11 \
  --blocks blocks.json

